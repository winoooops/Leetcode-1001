# 完全背包 

假设有 `n` 种物品, 每种物品有一个重量`weight[i]`和一个价值`value[i]`. 但每种物品的数量是**无限**的; 同时有一个背包, 最大载重量为 M, 现在从 n 中选取若干件(同一种物品可以选择多次), 使其重量的和小于或等于 M, 使得价值的和最大. 

> **完全背包和01背包问题唯一不同的地方就是，每种物品有无限件。**

## 思路 

因为一个物品现在可以拿无限个, 所以队友某一件物品来说, 可以采取的拿取策略的下限就是一个都不拿即 0 个, 上限就是拿取 `当前重量 / 物品重量` 个, 记作 k 个. 所以这个问题可以在 [0/1背包](../0-1-knapsack/)的基础上多一个0-k的循环(**每一个子问题都是一个0/1背包问题**).

