# 二叉树

## 二叉树的存储方式

### 链式存储

用指针存储. 通常用链式存储存储二叉树.

![linkedlist](../static/img/binary-tree/linkedlist-store.png)

### 顺序存储

用数组存储. 如果父节点的数组下标是 i，那么它的左孩子就是 i * 2 + 1，右孩子就是 i * 2 + 2。
![array](../static/img/binary-tree/array-store.png)

## 二叉树的种类

### 满二叉树 | Full Binary Tree

> 如果一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上，则这棵二叉树为满二叉树。

![full-binary-tree](../static/img/binary-tree/full-binary-tree.png)


### 完全二叉树 | Complete Binary Tree

> 在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2^(h-1)  个节点。

![complete-binary-tree](../static/img/binary-tree/complete-binary-tree.png)

> [!WARNING]
> 满二叉树必为完全二叉树, 完全二叉树不一定是满二叉树.

### 二叉搜索树 | Binary Search Tree

* 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
* 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
* 它的左、右子树也分别为二叉排序树

![binary-search-tree](../static/img/binary-tree/binary-search-tree.png)


### 平衡二叉搜索树 | AVL Tree

> 它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。

![AVL](../static/img/binary-tree/avl.png)


## 二叉树的遍历方式
> 我们做二叉树相关题目，经常会使用递归的方式来实现深度优先遍历，也就是实现前中后序遍历，使用递归是比较方便的。之前我们讲栈与队列的时候，就说过栈其实就是递归的一种是实现结构，也就说前中后序遍历的逻辑其实都是可以借助栈使用非递归的方式来实现的。而广度优先遍历的实现一般使用队列来实现，这也是队列先进先出的特点所决定的，因为需要先进先出的结构，才能一层一层的来遍历二叉树。

二叉树主要有深度优先, 和广度优先两种遍历方式.

### [二叉树的深度遍历](./dfs.md)
> 深度遍历中的前序, 中序和后序遍历方式见下图
> 这里前中后，其实指的就是中间节点的遍历顺序，只要大家记住 前中后序指的就是中间节点的位置就可以了。

* 涉及到二叉树的构造，无论普通二叉树还是二叉搜索树一定前序，都是先构造中节点。
* 求普通二叉树的属性，一般是后序，一般要通过递归函数的返回值做计算。
* 求二叉搜索树的属性，一定是中序了，要不白瞎了有序性了。

注意在普通二叉树的属性中，我用的是一般为后序，例如单纯求深度就用前序，二叉树：找所有路径 (opens new window)也用了前序，这是为了方便让父节点指向子节点。

> ![depth-order](../static/img/binary-tree/depth-order.png)

### [广度优先层次遍历](./level-order/README.md)

## 常见题型

### 二叉树的层序遍历

* [102.二叉树的层序遍历](./level-order/102/)
* [107.二叉树的层序遍历II](./level-order/107/)
* [199.二叉树的右视图](./level-order/199/)
* [637.二叉树的层平均值](./level-order/637/)
* [429.N叉树的层序遍历](./level-order/429/)
* [515.二叉树的层最大值](./level-order/515/)


### 二叉树的深度问题 
* [104.二叉树的深度](./level-order/104/) 
    * 层序遍历 + 二维数组
    * 递归: 回溯(后序遍历)
* [111.二叉树的最小深度](./level-order/111/)
    * 陷阱: 最小深度需要满足左子树都为空才行
    * 层序遍历: 遇到左右子树为空的情况返回当前深度
    * 递归: 如果eithre左右子树为空,返回另一个子树的高度, 否则取最小值
* [559.N叉树的最大层数](./level-order/559/)
    * 层序遍历: 二维数组的长度

### 二叉树的属性
* [101.对称二叉树](./isSymmetric/README.md)
    * 递归: 叶子节点必对称, 判断左右子树是否对称
    * 迭代: 两两推入栈, 可使用`dequeue`
    * 层序: 数组是否对称(子节点为空应该推送null到队列中)
* [222.完全二叉树的节点数量](./countNodes/README.md)
    * 递归: 利用完全二叉树的特性
      * 叶子节点为完全二叉树
      * `完全二叉树的节点数量 = Math.pow(2, 节点高度)`
      * 如果左右子树高度不同, 那么必有一棵树是完美二叉树, 一棵树是完全二叉树
    * 层序遍历: 二维数组的长度和
    * 迭代: 后序遍历
* [110.平衡二叉树](./isBalance/README.md)
    * 递归I: 左子树和右子树的高度差 <= 1; 左子树和右子树都是平衡二叉树
    * 递归II: 递归返回左子树和右子树的高度; 如果高度差 > 1, 返回-1
* [257.二叉树的所有路径](./binary-tree-paths/README.md)
    * 迭代: 前序遍历(隐含回溯) + 路径栈 
    * 遍历: 递归左右子树, 遇到没有子树的节点终止递归
* [404.二叉树的左叶子只和](./sum-of-left-leaves/README.md)
    * 三个条件: 叶子节点; 左边的; 不为空
      * 从当前节点无法判断是否是左叶子, 需要跨级判断 
    * 递归: 后序递归/前序递归, 判断 
    * 迭代法: 判断每一个节点的左子树
* [513.左下角的值](./bottom-left-tree/)
    * 层序遍历: 最后层的第一个
    * 队列递归 + 高度回溯 = 找最深处左边的值
* 路径总和 
    * [113.存储所有路径总和](./pathSum/)
      * 递归整棵树, 不需要返回值
    * [112.存在符合目标值的路径中和](./hasPathSum/)
      * 不递归整棵树, 找到即返回, 所以需要有返回值

### 改造二叉树 
* [226.翻转二叉树](./invertTree/)
   * 层序遍历: 对调层序遍历的节点的左右子树
   * 前序遍历: 递归对调左右即可
* [构造二叉树](./contruct-binary-tree/README.md)
   * [105.前序,中序构造二叉树](./contruct-binary-tree/105/)
     * 前序第一个元素为根节点 
     * 找到根节点, 在中序数组中分割区间
   * [106.后序,中序构造二叉树](./contruct-binary-tree/106/)
     * 后序最后一个元素为根节点 
     * 找到根节点, 在中序数组中分割区间
* [654.构造最大二叉树](./max-binary-tree/)
   * 用最大值在数组中分割区间 
* [617.合并二叉树](./merge-tree/)
   * 递归: 创造新的二叉树, 值为两颗二叉树值的和
   * 迭代: 同时推送两颗二叉树的节点
      * 如果其中一棵的左右子树为空, 修改第一棵树为不空的那个
      * 否则相加

### 二叉搜索树

* [98.验证二叉搜索树](./isValidBST/README.md)
  * 根据区间递归
  * 储存上一个节点; 中序遍历(二叉树特性), 判断是否小于上个节点(如果是,不满足)
* [700.搜索二叉搜索树](./searchBST/)
  * 利用特性, 判断节点和目标值大小, 只需要走一个子树
* [530.二叉搜索树的最小差值](./minimal-difference-bst/)
  * 等同于判断有序数组的最小差值
* [501.二叉树的众数](./modeBST/)
  * 等同于有序数组的众数
* [538.二叉搜索树转换成累加树](./convert-bst/)
  * 逆中序遍历, 可用递归和迭代
* [108.有序数组转化为二叉搜索树](./sortedArrayToBST/)
  * 递归: 通过数组的中点分割区间
  * 迭代: 使用节点栈, 左区间栈, 右区间栈
* [235.二叉搜索树的公共祖先](./lowest-common-ancestor/)
  * 递归: 如果为两个节点任意, 直接返回; 否则递归查找左右节点
  * 二叉搜索树的属性: 递归的时候加上判断, 只需要查找一边
* [701.插入二叉搜索树节点](./insert-bst/) 
  * 递归: 通过二叉树特性找到子节点为空的节点, 插入即可
* [450.删除二叉搜索树节点](./delete-bst/)
  * 删除需要判断: 是否为空节点, 是否没有子树, 是否其中一个子树为空, 如果都不是这需要剪枝(左子树到右子树的bottomleft)
* [669.修剪二叉搜索树](./trim-bst/)
  * 在递归的时候需要注意, 不满足条件的节点的子树可能满足条件

![topics](../static/img/binary-tree/topics.png)
![review](../static/img/binary-tree/review.png)
