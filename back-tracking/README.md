## 递归与回溯

> **只要有递归, 就会有回溯**

**因为回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案**，所以回溯法是纯暴力的搜索, 并不是高效的算法. 如果想让回溯法高效一些，可以加一些剪枝的操作，但也改不了回溯法就是穷举的本质。

## 回溯法 ⇒ `N叉树`

**回溯法解决的问题都可以抽象为树形结构, 即转换成`N叉树`来理解**

![](../static/img/back-tracking/backtrackingistree.png)


### 回溯法模板

```tsx
function backTracking(args: any[]): void {
	// 中止条件 
	if(condition) {
    /****
    * Do something here 
    ****/
		return  
	}
  
	// 单层搜索处理的逻辑
	for(/* 树中元素 */) {
		// 处理节点
    
		// 递归 
		backTracking(/*...参数...*/)

		// 回溯, 撤销处理结果(恢复现场)
	}
}
```

## 解决的问题

### 组合问题

组合没有顺序

### 排列问题
排列有顺序, 强调元素的顺序

### 切割问题

### 子集问题

### 棋盘问题
N皇后, 解数独